<!doctype html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Fishy Screen</title>
  <style>
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      user-select: none;
    }

    /* –§–æ–Ω */
    body {
      background: url("1.png") center / cover no-repeat fixed;
    }

    /* –õ—ë–≥–∫–∏–π "—Ç—É–º–∞–Ω", —á—Ç–æ–±—ã —Ä—ã–±–∫–∏ —á–∏—Ç–∞–ª–∏—Å—å –ª—É—á—à–µ */
    .veil {
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at 30% 20%, rgba(255,255,255,.15), rgba(255,255,255,0) 55%),
                  radial-gradient(circle at 80% 30%, rgba(255,255,255,.10), rgba(255,255,255,0) 55%);
      pointer-events: none;
    }

    #ocean {
      position: fixed;
      inset: 0;
      overflow: hidden;
    }

    .fish {
      position: absolute;
      will-change: transform;
      cursor: pointer;
      /* —á—Ç–æ–±—ã –∫–ª–∏–∫–∏ –ª–æ–≤–∏–ª–∏—Å—å –Ω–æ—Ä–º–∞–ª—å–Ω–æ */
      touch-action: manipulation;
      filter: drop-shadow(0 8px 10px rgba(0,0,0,.18));
    }

    .fish img {
      display: block;
      width: 100%;
      height: auto;
      pointer-events: none; /* —á—Ç–æ–±—ã hover/click –±—ã–ª –Ω–∞ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–µ .fish */
      transform: translateY(0);
      will-change: transform;
    }

    /* –ß—É—Ç—å –±–æ–ª—å—à–µ "–∂–∏–≤–æ—Å—Ç–∏" –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏ */
    .fish.is-active {
      filter: drop-shadow(0 10px 14px rgba(0,0,0,.25));
    }

    /* –ü—Ä—ã–∂–æ–∫ –ø—Ä–∏ –∫–ª–∏–∫–µ (–Ω–∞ —Å–∞–º —Å–ø—Ä–∞–π—Ç, —á—Ç–æ–±—ã –Ω–µ –ª–æ–º–∞—Ç—å transform –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞) */
    .fish img.jump {
      animation: jump 260ms cubic-bezier(.2,.9,.2,1);
    }

    @keyframes jump {
      0%   { transform: translateY(0) scale(1); }
      45%  { transform: translateY(-26px) scale(1.02); }
      100% { transform: translateY(0) scale(1); }
    }

    /* –ù–µ–±–æ–ª—å—à–∞—è –ø–æ–¥—Å–∫–∞–∑–∫–∞ */
    .hint {
      position: fixed;
      left: 14px;
      bottom: 14px;
      padding: 10px 12px;
      background: rgba(255,255,255,.75);
      backdrop-filter: blur(6px);
      border-radius: 14px;
      font-size: 14px;
      color: rgba(0,0,0,.75);
      box-shadow: 0 10px 24px rgba(0,0,0,.12);
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="ocean"></div>
  <div class="veil"></div>
  <div class="hint">–ù–∞–≤–µ–¥–∏ –Ω–∞ —Ä—ã–±–∫—É ‚Äî –æ–Ω–∞ –Ω–∞—á–Ω—ë—Ç –∞–∫—Ç–∏–≤–Ω–æ –ø–ª–∞–≤–∞—Ç—å. –ö–ª–∏–∫ ‚Äî –ø–æ–¥–ø—Ä—ã–≥–Ω–µ—Ç üêü</div>

  <script>
    (() => {
      const ocean = document.getElementById("ocean");
      const SPRITES = ["2.png", "3.png", "4.png"];

      // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ ‚Äî –º–æ–∂–µ—à—å –º–µ–Ω—è—Ç—å
      const FISH_COUNT = 14;          // —Å–∫–æ–ª—å–∫–æ —Ä—ã–±–æ–∫
      const MIN_SIZE = 70;            // –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä (px)
      const MAX_SIZE = 170;           // –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä (px)
      const BASE_SPEED = [25, 65];    // –æ–±—ã—á–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å (px/sec) min/max
      const ACTIVE_SPEED = [90, 190]; // —Å–∫–æ—Ä–æ—Å—Ç—å –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏ (px/sec) min/max

      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      const rand = (a, b) => a + Math.random() * (b - a);
      const pick = (arr) => arr[(Math.random() * arr.length) | 0];

      let W = window.innerWidth;
      let H = window.innerHeight;

      const mouse = { x: W/2, y: H/2 };
      window.addEventListener("mousemove", (e) => { mouse.x = e.clientX; mouse.y = e.clientY; }, { passive: true });
      window.addEventListener("resize", () => { W = window.innerWidth; H = window.innerHeight; });

      class Fish {
        constructor() {
          this.el = document.createElement("div");
          this.el.className = "fish";

          this.img = document.createElement("img");
          this.img.src = pick(SPRITES);
          this.el.appendChild(this.img);

          // —Ä–∞–∑–º–µ—Ä—ã
          this.size = rand(MIN_SIZE, MAX_SIZE);
          this.el.style.width = this.size + "px";

          // –ø–æ–∑–∏—Ü–∏—è
          this.x = rand(0, Math.max(1, W - this.size));
          this.y = rand(0, Math.max(1, H - this.size));

          // —Å–∫–æ—Ä–æ—Å—Ç—å/–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
          const speed = rand(BASE_SPEED[0], BASE_SPEED[1]);
          const ang = rand(0, Math.PI * 2);
          this.vx = Math.cos(ang) * speed;
          this.vy = Math.sin(ang) * speed;

          // —Ä–µ–∂–∏–º—ã
          this.active = false;
          this.target = { x: rand(0, W), y: rand(0, H) };
          this.targetTimer = 0;

          // –Ω–µ–±–æ–ª—å—à–∞—è –ø–ª–∞–≤–Ω–∞—è "–≤–æ–ª–Ω—É—à–∫–∞"
          this.wobbleSeed = rand(0, 1000);

          // —Å–æ–±—ã—Ç–∏—è
          this.el.addEventListener("mouseenter", () => {
            this.active = true;
            this.el.classList.add("is-active");
            this.pickNewTarget(true);
          });

          this.el.addEventListener("mouseleave", () => {
            this.active = false;
            this.el.classList.remove("is-active");
          });

          this.el.addEventListener("click", () => {
            this.img.classList.remove("jump");
            // –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫ –∞–Ω–∏–º–∞—Ü–∏–∏
            void this.img.offsetWidth;
            this.img.classList.add("jump");
          });

          ocean.appendChild(this.el);
        }

        pickNewTarget(forceFar = false) {
          // —Ü–µ–ª—å "–ø–æ –≤—Å–µ–º—É —ç–∫—Ä–∞–Ω—É"
          let tx = rand(0, W);
          let ty = rand(0, H);

          if (forceFar) {
            // —á—Ç–æ–±—ã –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏ —Ü–µ–ª—å –Ω–µ –±—ã–ª–∞ —Ä—è–¥–æ–º ‚Äî —Ä—ã–±–∫–∞ —Ä–µ–∞–ª—å–Ω–æ —É—Ö–æ–¥–∏—Ç –≥—É–ª—è—Ç—å
            const tries = 6;
            for (let i = 0; i < tries; i++) {
              const cx = rand(0, W), cy = rand(0, H);
              const dx = cx - this.x, dy = cy - this.y;
              if (dx*dx + dy*dy > (Math.min(W,H)*0.18) ** 2) { tx = cx; ty = cy; break; }
            }
          }

          this.target.x = tx;
          this.target.y = ty;
          this.targetTimer = rand(0.7, 1.4); // —á–µ—Ä–µ–∑ —Å–∫–æ–ª—å–∫–æ —Å–µ–∫—É–Ω–¥ —Å–º–µ–Ω–∏—Ç—å —Ü–µ–ª—å
        }

        update(dt, t) {
          const maxX = Math.max(0, W - this.size);
          const maxY = Math.max(0, H - this.size);

          // –í –∞–∫—Ç–∏–≤–Ω–æ–º —Ä–µ–∂–∏–º–µ (–Ω–∞–≤–µ–¥—ë–Ω) ‚Äî —Ä—ã–±–∫–∞ "–≥—É–ª—è–µ—Ç" –∫ —Ü–µ–ª—è–º –ø–æ —ç–∫—Ä–∞–Ω—É
          if (this.active) {
            this.targetTimer -= dt;
            if (this.targetTimer <= 0) this.pickNewTarget();

            const dx = this.target.x - this.x;
            const dy = this.target.y - this.y;
            const dist = Math.hypot(dx, dy) || 1;

            // —Å–∫–æ—Ä–æ—Å—Ç—å –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞
            const desiredSpeed = rand(ACTIVE_SPEED[0], ACTIVE_SPEED[1]);
            const desiredVx = (dx / dist) * desiredSpeed;
            const desiredVy = (dy / dist) * desiredSpeed;

            // –ø–ª–∞–≤–Ω–æ–µ "—Ä—É–ª–µ–Ω–∏–µ" (steering)
            const steer = 0.09;
            this.vx += (desiredVx - this.vx) * steer;
            this.vy += (desiredVy - this.vy) * steer;
          } else {
            // –æ–±—ã—á–Ω—ã–π —Ä–µ–∂–∏–º ‚Äî –ª—ë–≥–∫–æ–µ –¥—Ä–µ–π—Ñ–æ–≤–∞–Ω–∏–µ + –Ω–µ–º–Ω–æ–≥–æ —Å–ª—É—á–∞–π–Ω–æ–≥–æ "–ø–ª–∞–≤–∞–Ω–∏—è"
            const drift = 0.012;
            this.vx += (rand(-10, 10) - this.vx * 0.02) * drift;
            this.vy += (rand(-10, 10) - this.vy * 0.02) * drift;

            // –æ–≥—Ä–∞–Ω–∏—á–∏–º –æ–±—â—É—é —Å–∫–æ—Ä–æ—Å—Ç—å
            const sp = Math.hypot(this.vx, this.vy);
            const spMax = BASE_SPEED[1];
            if (sp > spMax) {
              this.vx = (this.vx / sp) * spMax;
              this.vy = (this.vy / sp) * spMax;
            }
          }

          // –¥–≤–∏–∂–µ–Ω–∏–µ
          this.x += this.vx * dt;
          this.y += this.vy * dt;

          // –æ—Ç—Å–∫–æ–∫ –æ—Ç –∫—Ä–∞—ë–≤
          if (this.x < 0) { this.x = 0; this.vx = Math.abs(this.vx); }
          if (this.x > maxX) { this.x = maxX; this.vx = -Math.abs(this.vx); }
          if (this.y < 0) { this.y = 0; this.vy = Math.abs(this.vy); }
          if (this.y > maxY) { this.y = maxY; this.vy = -Math.abs(this.vy); }

          // –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏—è: –∫—É–¥–∞ –ø–ª—ã–≤—ë—Ç ‚Äî —Ç—É–¥–∞ –∏ ‚Äú—Å–º–æ—Ç—Ä–∏—Ç‚Äù
          const flip = this.vx < 0 ? -1 : 1;
          const rot = clamp(this.vy * 0.15, -12, 12); // –Ω–µ–±–æ–ª—å—à–æ–π –Ω–∞–∫–ª–æ–Ω
          const wobble = Math.sin((t + this.wobbleSeed) * 2.2) * 2.2; // –ª—ë–≥–∫–∞—è –≤–æ–ª–Ω—É—à–∫–∞

          this.el.style.transform =
            `translate3d(${this.x}px, ${this.y + wobble}px, 0) scaleX(${flip}) rotate(${rot}deg)`;
        }
      }

      // –°–æ–∑–¥–∞—ë–º —Ä—ã–±–æ–∫
      const fishes = Array.from({ length: FISH_COUNT }, () => new Fish());

      // –ê–Ω–∏–º–∞—Ü–∏–æ–Ω–Ω—ã–π —Ü–∏–∫–ª
      let last = performance.now();
      function tick(now) {
        const dt = Math.min(0.033, (now - last) / 1000); // –∑–∞—â–∏—Ç–∞ –æ—Ç "—Å–∫–∞—á–∫–æ–≤"
        last = now;

        const t = now / 1000;
        for (const f of fishes) f.update(dt, t);

        requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);
    })();
  </script>
</body>
</html>
